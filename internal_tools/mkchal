#!/usr/bin/env python3

import os
import sys
import re
import subprocess
import time
import tempfile
import shutil
import string
import glob
import zipfile
from pathlib import Path

def is_valid(line):
  if len(line.strip()) == 0:
    return True

  if line.strip().lower().startswith('flag format:'):
    return False

  if line.strip().lower() == 'attachment':
    return False

  if line.strip().lower().startswith('download link') or  line.strip().lower().startswith('challenge author'):
    return False

  if line.strip().lower().startswith('fastest solvers'):
    return False

  if re.search('solves\s+\d+', line.lower()):
    return False

  if re.search('score:\s*\d+', line.lower()):
    return False

  if re.search('\d+[ \t]+points', line.lower()) or re.search('\d+[ \t]*solves', line.lower()) or re.search('\d+[ \t]+solve', line.lower()) or re.search('\d+[ \t]+score', line.lower()):
    return False

  if re.fullmatch("[0-9a-z-]+\.zip", line.strip().lower()):
    return False

  if re.fullmatch("attachment:\s*[\w\.]+", line.strip().lower()):
    return False

  if re.search('\d+[ \t]*pt', line):
    return False

  if re.search(r'\d{2}/\d{2}, \d{2}:\d{2}:\d{2}', line):
    return False

  if line.lower().startswith('points:') or line.lower().startswith('solves:') or line.lower().startswith('topics:'):
    return False

  if 'points' in line.lower() and 'solves' in line.lower():
    return False

  is_all_numeric = True
  for l in line.strip().split():
    is_all_numeric = is_all_numeric and l.strip().isnumeric()
  if is_all_numeric:
    return False

  if line.strip().lower() in ['welcome', 'expert', 'beginner', 'web', 're', 'rev', 'reverse', 'reversing', 'pwn', 'crypto', 'misc', 'tags', 'description', 'cry', 'pts', 'solves', 'description', 'warmup', 'easy', 'medium', 'hard', 'insane', 'forensics', 'forensic', 'score', 'cryptography', 'submit flag', 'binary', 'steganography', 'unrated', 'reverse engineering']:
    return False

  if re.fullmatch("category (forensics|reverse|web|crypto|pwn)", line.strip().lower()):
    return False

  if re.fullmatch("category: (forensics|reverse|web|crypto|pwn|reverse engineering|game hacking|misc)", line.strip().lower()):
    return False

  if re.fullmatch("level (easy|medium|hard)", line.strip().lower()):
    return False

  if re.fullmatch("difficulty: (easy|medium|hard|baby|guessy)", line.strip().lower()):
    return False

  if re.match(r"author\s*:", line.strip().lower()):
    return False

  if re.fullmatch(r"first blood: (\w|\.)+", line.strip().lower()):
    return False

  if re.fullmatch(r"(http|https)://\d+\.\d+\.\d+\.\d+/", line.strip().lower()):
    return False

  if re.fullmatch(r"\d+\.\d+\.\d+\.\d+:\d+", line.strip().lower()):
    return False

  if re.fullmatch(r"nc \d+\.\d+\.\d+\.\d+ \d+", line.strip().lower()):
    return False

  if re.fullmatch(r"nc [a-z0-9\-]{1,63}(\.[a-z0-9-]{1,63})+ \d+", line.strip().lower()):
    return False

  if re.fullmatch(r"\d{1,2}/\d{1,2}/\d{4}", line.strip().lower()):
    return False

  return True

def replace_special_characters(line):
  return line.replace(u'\u1d2c', 'A').replace(u'\u1d64', 'U').replace(u'\u00e4', 'a').replace('@', 'a').replace('$', 's').replace('&', 'and').replace('üëª', 'Ghost').replace('√®', 'e').replace('üèÉ', 'Ran').replace('√©', 'e').replace('√∂', 'o').replace('√â', 'E').replace('‡¥ï‡µÅ‡¥ü‡µç‡¥ü‡¥ø', 'child')

def get_challenge_name(line):
  for original_name in reversed(line.strip().split('/')):
    if original_name not in ['beginner', 'medium', 'hard', 'easy']:
      break

  args = re.sub('(\d+ solves|\d+ pts$)', '', original_name.strip()).strip().split()

  tokens = []
  for a in args:
    tokens.extend(re.sub(r'[^0-9a-zA-Z_+\.]+', ' ', a.replace("'", "")).strip().split())

  return '_'.join(tokens)

def unpack_file(fname):
  dname = os.path.dirname(fname)

  if zipfile.is_zipfile(fname):
    return subprocess.run(['7z', 'x', fname, '-o' + dname + '/' + Path(fname).stem], shell=False).returncode == 0
  elif not fname.endswith('.cpio.gz') and (fname.endswith('.tar.gz') or fname.endswith('.tgz') or fname.endswith('.txz') or fname.endswith('.tar.xz') or fname.endswith('.tzst') or fname.endswith('.gz') or fname.endswith('.tar.zst')):
    return subprocess.run(['tar', 'xzvf', fname, '-C', dname], shell=False).returncode == 0
  elif fname.endswith('.tar'):
    return subprocess.run(['tar', 'xvf', fname, '-C', dname], shell=False).returncode == 0
  elif fname.endswith('.7z'):
    return subprocess.run(['7z', 'x', fname, '-o' + dname], shell=False).returncode == 0
  elif fname.endswith('.rar'):
    return subprocess.run(['unrar', 'x', fname, dname], shell=False).returncode == 0

  return False

if __name__ == '__main__':
  # create challenge directory
  lines = '\n'.join([re.sub(r'(\d+[ \t]+points|\d+pts)', r'\n\1', l.rstrip()) for l in sys.stdin.readlines()])
  lines = re.sub('Author:\s*[\w,\- ]+', '', lines).strip().split('\n')
  chal_name = get_challenge_name(replace_special_characters(lines[0]))

  lines = '\n'.join(lines[1:]).strip().split('\n')
  lines = [l.strip('\n') for l in lines if is_valid(l)]

  shutil.rmtree(chal_name, ignore_errors=True)
  os.mkdir(chal_name)

  download_dir = os.path.expanduser('~/Downloads')

  with tempfile.TemporaryDirectory() as tmp_path:
    # move all the files downloaded in the past 60 seconds into the tmp directory
    for f in os.listdir(download_dir):
      fname = os.path.join(download_dir, f)

      if time.time() - os.path.getmtime(fname) <= 60:
        subprocess.run(['mv', fname, tmp_path])

    # unpack files recursively until no packed file is available
    # curr_dir = os.getcwd()
    # os.chdir(tmp_path)

    while True:
      found_packed_files = False

      for root, _, files in os.walk(tmp_path):
        for f in files:
          fname = os.path.join(root, f)
          if unpack_file(fname):
            found_packed_files = True
            os.remove(fname)

      if not found_packed_files:
        break

    # os.chdir(curr_dir)

    # clean up unnecessary files
    os.system('rm -rf `find "%s" -name __MACOSX`' % tmp_path)

    # identify the directories/files needed to be copied to the final challenge directory.
    final_path = tmp_path
    while True:
      children = os.listdir(final_path)
      if len(children) == 0 or len(children) > 1:
        break

      child_path = os.path.join(final_path, children[0])

      if not os.path.isdir(child_path):
        break

      final_path = child_path

    os.system('find "%s" -name "*" -depth 1 | while read line; do mv "$line" "%s"; done' % (final_path, chal_name))

  # compress any pcap or pcapng file
  os.system("find \"%s\" -type f -name \"*.pcap*\" | grep -E -e '.*\.pcap(ng){0,1}$' | xargs -n 1 xz" % (chal_name))

  readme = ''
  if os.path.exists('%s/README.md' % chal_name):
    readme = open('%s/README.md' % chal_name).read()
  readme = re.sub('\n{3,}', '\n\n', '\n'.join(lines[0:]).strip()) + '\n' + '\n\n' + readme
  open('%s/README.md' % chal_name, 'w').write(readme.strip() + '\n')

  print('\n\n+++++++++++++++++++++++++++++++++++++++++++++++')
  print(chal_name)
  subprocess.run(['ls', chal_name])
  print('+++++++++++++++++++++++++++++++++++++++++++++++\n')
  print('\n-----------------------------------------------')
  subprocess.run(['cat', chal_name + '/README.md'])
  print('-----------------------------------------------\n')
